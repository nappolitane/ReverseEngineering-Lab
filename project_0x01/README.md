# Project 0x01

In this task we have an ELF binary, a pseudo-malicious ransomware. We have to understand how this ransomware actually affects the operating system, how the encryption is done and eventually find a way to decrypt the files.

Initially, i executed the binary in a folder that had another text file inside with a simple "hello" to see how this would get encrypted, and i realised nothing was actually changed in the operating system. So i first tried to use **ltrace** on the binary and i observed a **strcmp** with a string inside "encrypt_me_baby_one_more_time". So i thought maybe it checks the names of the files in the file system and only encrypts the ones that have that name. So i was right about checking the names but it only encrypts the files with that name and that are in that same folder with the binary.

![alt text](ltrace.png?raw=true)

We can see in the image above that the binary only encrypts the file named "encrypt_me_baby_one_more_time" not only the content of the file, but also the name of the binary. We can also see that the ltrace output ends in a ptrace function meaning that the binary is using ptrace call to implement anti-debugging mechanism. After running the binary having multiple text files named "encrypt_me_baby_one_more_time" with identical contents, i realised that the encryption is pretty good with no repetition or anything like that, with one exception and that is the "fmi_re_course" string that appears inside the contents of the encrypted file. After running the binary to test multiple different kind of files, the "fmi_re_course" string actually appears inside every file encrypted by the binary, no matter what is inside the file before the encryption. There are two things that i observed when analyzing the different encryptions resulted from the binary, one is that the length of the encrypted bytes before the string is the same with what was before the encryption and the other thing is that what is after that string is always the same size which is 29.

The next thing i did was to open the binary using IDA and decompile it. The code is pretty basic and i quickly found the function that does the encryption and writes to the file, and this function confirms what we saw during the prior analysis.

![alt text](encfunc.png?raw=true)

The first thing that we can see inside the function above is the string "fmi_re_course" and the **fwrite** function calls. So we can be pretty sure that we are in the right place. If we look at the function we can see that there are three main parts (the three for loops), the second being the one that writes to file the string "fmi_re_course". So this confirms the fact that the encrypted file is being composed on three parts with the second being that "fmi_re_course" string, just as we analysed earlier. Going back to the function we can see that inside the first loop the **rand** function is being used to add values to every byte of the string read from the file and later being written to the final file. Inside the third loop is used the same technique, it adds random values to every byte from a vector, but we can't find out what the initial vector is. So the next thing i did was to open the binary with edb-debugger, and set a breakpoint to address of the third loop instruction *v9 = v8[i]* that is *0x004017EF* in order to actually see what is inside that *v8* vector.

![alt text](debug.png?raw=true)

As we can see in the above image, the assembly instruction sets a value on the stack with the AL value and if we look in the right panel where the registers are, the RAX is 0x65 that represents the "e" letter in ASCII and if we run in the loop to the second time the value is 0x6e that represents the "n" letter. Taking into consideration the length that is 29 this string is actually "encrypt_me_baby_one_more_time".

So the encryption is basically adding random values to every byte from the file and write to file those modified bytes, then writes the "fmi_re_course" string to file, then adds random values to every byte from the "encrypt_me_baby_one_more_time" string then writes those modified bytes to file. Because the algorithm is using random in the encryption algorithm it is pretty hard to break it. But if we search the google about this libc rand function (https://stackoverflow.com/questions/15480838/prediction-of-the-next-number-generated-by-c-glibc-rand) we would find that the **rand** function can actually be unsecure if we have a string of a 30 or so bytes known at the runtime, this way we could decrypt anything. And we actually have that "encrypt_me_baby_one_more_time" string that we know it will get randomised.

